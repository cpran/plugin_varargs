#! This script is part of the varargs CPrAN plugin for Praat.
#! The latest version is available through CPrAN or at
#! <http://cpran.net/plugins/varargs>
#!
#! The varargs plugin is free software: you can redistribute it
#! and/or modify it under the terms of the GNU General Public
#! License as published by the Free Software Foundation, either
#! version 3 of the License, or (at your option) any later version.
#!
#! The varargs plugin is distributed in the hope that it will be
#! useful, but WITHOUT ANY WARRANTY; without even the implied warranty
#! of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#! GNU General Public License for more details.
#!
#! You should have received a copy of the GNU General Public License
#! along with utils. If not, see <http://www.gnu.org/licenses/>.
#!
#! Copyright 2016 Jose Joaquin Atria

#! ~~~ params
#! in:
#!   - .argv$: >
#!       A string that will be parsed exactly like what comes after
#!       the `@` in a procedure call.
#! ~~~
procedure varargs: .argv$
  .base$ = replace_regex$(.argv$, "^\s*([_a-zA-Z0-9\.]+)\s*([:(]?).*", "\1\2", 0)
  .args$ = .argv$ - ")"

  .r$ = right$(.base$)
  if .r$ == "(" or .r$ == ":"
    .base$ = .base$ - .r$
    .args$ = extractLine$(.args$, .r$)
    if .r$ == ":" and .args$ == ""
      exitScript: "Empty formula:" + newline$ +
         ... "« " + .argv$ + " »"
    endif
  else
    .args$ = extractLine$(.args$, " ")
  endif

  @arg: .args$
  @'.base$'()
  if variableExists(.base$ + "." + arg.t$)
    call '.base$'.'arg.t$' 'arg.v$'

  else
    exitScript: "No procedure with that signature:" + newline$ +
      ... "« " + .argv$ + " »"
  endif

  for .i to arg.n
    arg.v$[.i] = ""
  endfor
endproc

#! ~~~ params
#! in:
#!   - .in$: A comma-separated argument list (as if to be used with `@`)
#! out:
#!   - .n: The number of parsed arguments
#!   - .v$: A space-separated argument list (as if to be used with `call`)
#!   - .t$: >
#!       The signature of parsed arguments, encoded as a string of "n" (for
#!       numerics) and "s" (for strings) characters, one per parsed argument.
#!       If no arguments were passed, `.t$` will be `nil`.
#!   - v$[]: A list of each individual argument, all of them as strings.
#! ~~~
procedure arg: .in$
  .length = length(.in$)
  .string = 0

  if variableExists("arg.n")
    for .i to arg.n
      arg.v$[.i] = ""
    endfor
  endif

  .n = 0
  .v$ = ""
  .t$ = ""
  if .length
    .n = 1

    # Walk through argument string
    for .i to .length
      .c$ = mid$(.in$, .i, 1)

      if !variableExists(".v$[" + string$(.n) + "]")
        .v$[.n] = ""
      endif


      # Found a quotation mark
      if .c$ == """"
        # It is an escaped quotation mark
        if .i < .length and mid$(.in$, .i + 1 , 1) == """"
          .v$[.n] = .v$[.n] + """"
          .i += 1
        else
          # Toggle string status
          .string = 1 - .string

          # New string found
          if .string
            .t$ = .t$ + "s"
          endif
        endif

      # Found a comma, not in a string
      elsif .c$ == "," and !.string
        if right$(.t$) == "s"
          .v$ = .v$ + """" + .v$[.n] + """ "
        else
          .v$ = .v$ + .v$[.n] + " "
        endif

        .n += 1
      # Ignore spaces not in strings
      elsif .c$ == " " and !.string
      # Save every other character to the current variable
      else
        # New non-string found
        # This can be a numeric or a variable
        if .v$[.n] == "" and !.string
          .t$ = .t$ + "n"
        endif

        .v$[.n] = .v$[.n] + .c$
      endif
    endfor
    .v$ = .v$ + .v$[.n]

    # String status left open
    if .string
      exitScript: "No closing quote in argument list:" + newline$ +
        ... "« " + .in$ + " »"
    endif

    # Loop through non-strings to find variable names
    # and replace their values into the argument list
    .length = length(.t$)
    for .i to .length
      .c$ = mid$(.t$, .i, 1)
      if .c$ == "n"
        .num = number(.v$[.i])
        if .num == undefined
          # Is a non-number non-string: a variable name
          if !variableExists(.v$[.i])
            exitScript: "Unknown variable:" + newline$ +
              ... "» " + .v$[.i] + newline$ +
              ... " found in " + newline$ + "» " + .in$ + " «"
          else
            .varname$ = .v$[.i]
            if right$(.varname$) == "$"
              .v$[.i] = '.varname$'
              .t$ = left$(.t$, .i - 1) + "s" + right$(.t$, length(.t$) - .i)
            else
              .v$[.i] = string$('.varname$')
            endif
          endif
        endif
      endif
  endfor

  # No arguments
  else
    .t$ = "nil"
  endif

endproc
